package magdysyuk.backuper.source.logger;

/**
 * List of possible log messages.
 */
public enum TextMessage {

	// Used in logger for message about error point 
	LOGGER_CALLER_CLASS_NAME_AND_METHOD_NAME ("Class: \"{0}\", method \"{1}\""),
	
	
	FILE_READ_START (">>>	Start to try to read input file: \"{0}\""),
	FILE_READ_METHOD_END ("<<<	End method of starting read file (was received input file stream)"),
	FILE_IS_READABLE ("File exists and is readable. Filepath: \"{0}\", length of file (in bytes): \"{1,number,integer}\", is it normal (not directory) file: \"{2}\""),
	FILE_IS_NOT_READABLE ("File can not be read. Filepath: \"{0}\""),
	FILE_READ_IMPOSSIBLE ("Impossible read file. Filepath: \"{0}\", size of buffer (should be >0): \"{1,number,integer}\""),
	FILE_READ_WILL_BE_SUCCESSFUL ("File could be read successful (file is readable and file input stream received). Filepath: \"{0}\""),
	FILE_WRITE_START (">>>	Start to try to write information in file. Output filepath: \"{0}\""),
	FILE_WRITE_METHOD_END ("<<<	End method of receiving output file stream"),
	FILE_IS_WRITEABLE ("File is writeable. Filepath: \"{0}\""),
	FILE_IS_NOT_WRITEABLE ("File is not writeable. Filepath: \"{0}\""),
	FILE_WRITE_IMPOSSIBLE ("Impossible write to file. Filepath: \"{0}\", size of buffer (should be >0): \"{1,number,integer}\""),
	FILE_WRITE_WILL_BE_SUCCESSFUL ("File could be written successful (file is writeable and file output stream received). Filepath: \"{0}\""),
	FILE_DOES_NOT_EXISTS ("File does not exists. Filepath: \"{0}\""),
	FILE_CREATED_SUCCESSFUL ("File was created successful. Filepath: \"{0}\""),
	FILE_CREATE_IMPOSSIBLE ("Impossible create file or directory. Filepath: \"{0}\""),
	FILE_DELETE_IMPOSSIBLE ("Impossible remove file or directory, Filepath: \"{0}\""),
	FILE_WRITE_PROCESSING_DATA_START (">>>	Start stream-processing and writing data"),
	FILE_WRITE_PROCESSING_DATA_END ("<<<	End stream-processing and writing data"),
	FILE_WRITE_PROCESSING_DATA_FILE_INFO ("Begin to write data from input file to special output stream. Input filepath: \"{0}\", length of file (in bytes): \"{1,number,integer}\", is it normal (not directory) file: \"{2}\""),
	FILE_WRITE_PROCESSING_DATA_CURRENT_CONDITION ("Current number readed and processed input bytes in this iteration: \"{0}\". Total number readed and processed input bytes at this moment: \"{1,number,integer}\". Number loops iterations: \"{2,number,integer}\""),
	FILE_WRITE_PROCESSING_DATA_SUCCESSFUL ("Total number readed and processed input bytes: \"{0,number,integer}\". Input data was readed in loop (total number iterations: \"{1,number,integer}\") through buffer (length of buffer byte array: \"{2,number,integer}\")"),
	FILE_MOVE_IMPOSSIBLE ("Impossible move file to directory. Source data: \"{0}\", destination directory: \"{1}\""),
	DIRECTORIES_COMPARE_IMPOSSIBLE ("Impossible to compare contains of two directories: \"{0}\" and \"{1}\""),
	SPECIFIC_FILE_CREATED_SUCCESSFUL("Specific file created successful. Destination directory, where file should be placed: \"{0}\", prefix (part of file name before UUID): \"{1}\", file type: \"{2}\". Path to created specific file: \"{3}\""),
	SPECIFIC_FILE_CREATE_IMPOSSIBLE("Impossible create specific file. Destination directory, where file should be placed: \"{0}\", prefix (part of file name before UUID): \"{1}\", file type: \"{2}\""),
	
	CRYPT_DATA_START (">>>	Start data crypt operation (encryption or decryption). If chosen Encryption, cipher mode is equal 1; if chosen Decryption, cipher mode is equal 2. Now chosen cipher mode: \"{0,number,integer}\""),
	CRYPT_DATA_END ("<<<	End data crypt operation. Result (true if successful, false otherwise): \"{0}\""),
	CRYPT_DATA_SUCCESSFUL ("Data was crypted successful"),
	CRYPT_DATA_IMPOSSIBLE ("Impossible do crypt operation"),
	CRYPT_DATA_PROCESSING_START (">>>	Start crypt processing data"),
	CRYPT_DATA_PROCESSING_END ("<<<	End crypt processing data. Result of operation (was de/en-crypt successful?): \"{0}\""),
	CRYPT_DATA_PROCESSING_IMPOSSIBLE ("Impossible do crypt processing data"),
	CRYPT_DATA_CLOSE_DESCRIPTORS_IMPOSSIBLE ("Impossible close input / output stream which used in crypt data processsing"),
	CRYPT_FILE_START (">>>	Start crypt file operation (encryption or decryption). If chosen Encryption, cipher mode is equal 1; if chosen Decryption, cipher mode is equal 2. Now chosen cipher mode: \"{0,number,integer}\". Input filepath: \"{1}\". Output directory filepath: \"{2}\". Cipher mode: \"{3}\". Padding: \"{4}\""),
	CRYPT_FILE_END ("<<<	End crypt file operation. Result (true if successful, false otherwise): \"{0}\""),
	
	SECRET_KEY_SPEC_START_GETTING (">>>	Start getting secret key spec"),
	SECRET_KEY_SPEC_END_GETTING ("<<<	End getting secret key spec"),
	SECRET_KEY_SPEC_CREATED ("SecretKeySpec created successful"),
	DESEDE_KEY_SPEC_START_GETTING (">>>	Start getting DESede key spec"),
	DESEDE_KEY_SPEC_END_GETTING ("<<<	End getting DESede key spec"),
	DESEDE_KEY_SPEC_CREATED ("DESedeKeySpec created successful"),
	SECRET_KEY_FACTORY_ALGORITHM_IS_NULL ("Impossible create instance of SecretKeyFactory because input parameter algorithm name is NULL"),
	SECRET_KEY_FACTORY_ALGORITHM_IS_INVALID ("Impossible create instance of SecretKeyFactory because input parameter algorithm name is invalid. Algorithm name: \"{0}\""),
	SECRET_KEY_FACTORY_INVALID_KEY_SPEC ("Impossible generate secret key on secret key factory because input KeySpec is invalid"),
	SECRET_KEY_FACTORY_INSTANCE_CREATED ("Successful created instance of SecretKeyFactory. Specified algorithm: \"{0}\""),
	PBE_KEY_SECRET_ENCODED_START_GETTING (">>>	Start getting secret PBE key encoded"),
	PBE_KEY_SECRET_ENCODED_END_GETTING ("<<<	End getting secret PBE key encoded"),
	PBE_KEY_SECRET_ENCODED_LENGTH_POSITIVE ("Length of byte array encoded secret PBE key: \"{0,number,integer}\""),
	PBE_KEY_SECRET_ENCODED_IS_EMPTY_OR_NULL ("Byte array of encoded PBE key is empty or NULL"),
	PBE_KEY_IS_CALCULATED ("Successful calculated secret PBE key from PBEKeySpec"),
	PBE_KEY_SPEC_START_GETTING (">>>	Start getting PBEKeySpec"),
	PBE_KEY_SPEC_END_GETTING ("<<<	End getting PBEKeySpec"),
	PBE_KEY_SPEC_IS_CALCULATED ("PBEKeySpec was successful calculated. Input parameters: length of password char array: \"{0,number,integer}\", length of salt byte array: \"{1,number,integer}\", iteration count: \"{2,number,integer}\", key length: \"{3,number,integer}\""),
	PBE_KEY_SPEC_INPUT_SALT_IS_EMPTY_OR_NULL ("Impossible to use PBE (password based encryption) because byte array of salt for hashing is empty (length 0) or NULL"),
	PBE_KEY_SPEC_INVALID_ITERATIONCOUNT_OR_KEYLENGTH ("Impossible to use PBE because iteration count or key length is invalid (non-positive). Iteration count: \"{0,number,integer}\". Key length: \"{1,number,integer}\". Addtition: salt byte array length: \"{2,number,integer}\""),
	NORMALIZED_PASSWORD_START_GETTING (">>>	Start getting normalized password"),
	NORMALIZED_PASSWORD_END_GETTING ("<<<	End getting normalized password"),
	NORMALIZED_PASSWORD_FULL_HASH_OF_INPUT_PASSWORD ("Full hash (length: \"{0,number,integer}\") of input password: \"{1}\""),
	NORMALIZED_PASSWORD_IS_CALCULATED ("Calculated normalized password (length: \"{0,number,integer}\"): \"{1}\""),
	IV_START_GETTING (">>>	Start getting IV (initialization vector of cipher)"),
	IV_END_GETTING ("<<<	End getting IV (initialization vector of cipher)"),
	IV_INPUT_BYTES_ARE_EMPTY_OR_NULL ("Impossible get IV because input byte array is empty (length 0) or NULL"),
	IV_IS_CALCULATED ("IV was successful calculated. Length of block for chosen crypto algorithm: \"{0,number,integer}\". Length of IV byte array: \"{1,number,integer}\". Length of input byte array: \"{2,number,integer}\", input byte array (converted to hex string): \"{3}\", output IV byte array (converted to hex string): \"{4}\""),
	SALT_FROM_PASSWORD_START_CALCULATING (">>>	Start calculating salt from password"),
	SALT_FROM_PASSWORD_END_CALCULATING ("<<<	End calculating salt from password"),
	SALT_FROM_PASSWORD_LENGTH_EQUALS_OR_OVER_HASH_PASSWORD ("Setted length of salt is equals or over than length of hash of password. Initial length of salt byte array: \"{0,number,integer}\", length of hash of password byte array: \"{1,number,integer}\". Decreased length of salt byte array: \"{2,number,integer}\""),
	SALT_FROM_PASSWORD_IS_CALCULATED ("Successful calculated salt from password. Length of input password char array: \"{0,number,integer}\". Length of calculated salt byte array: \"{1,number,integer}\". Planned length of salt: \"{2,number,integer}\". Total length of full hash: \"{3,number,integer}\". Salt (converted to hex string): \"{4}\". Full hash (converted to hex string): \"{5}\". For convertation from char array to byte array and back was used charset: \"{6}\". For hashing was used algorithm: \"{7}\""),
	SALT_FROM_PASSWORD_INVALID_LENGTH_OF_SALT ("Impossible calculate salt from password because required invalid length of salt byte array. Required length of salt: \"{0,number,integer}\""),
	SALT_FROM_PASSWORD_OUTPUT_BYTES_ARE_EMPTY_OR_NULL ("Impossible calculate salt from password: emergency error: input char array is not empty (length: \"{0,number,integer}\"), but output byte array is empty (length 0) or NULL"),
	SALT_FROM_PASSWORD_INPUT_PASSWORD_IS_EMPTY_OR_NULL ("Impossible get salt from part of hash of password because input password is empty or NULL"),
	AVAILABLE_CHARSETS ("Number of available charsets: \"{0}\". List of charsets: \"{1}\""),
	CHAR_ARRAY_TO_BYTE_ARRAY_CONVERTED_SUCCESSFUL ("Char array (length: \"{0,number,integer}\") was successful converted to byte array (length: \"{1,number,integer}\"). Used charset: \"{2}\""),
	CHAR_ARRAY_TO_BYTE_ARRAY_INPUT_CHARS_ARE_EMPTY_OR_NULL ("Impossible convert char array to byte array because input char array is empty (length 0) or NULL"),
	CHAR_ARRAY_TO_BYTE_ARRAY_OUTPUT_BYTES_ARE_EMPTY_OR_NULL ("Impossible convert char array to byte array: emergency error: input char array is not empty (length: \"{0,number,integer}\"), but output byte array is empty (length 0) or NULL"),
	CHAR_ARRAY_TO_BYTE_ARRAY_INVALID_CHARSET ("Impossible convert char array to byte array because given charset name is invalid. Charset name: \"{0}\""),
	
	HEX_STRING_FROM_BYTES ("Byte array (length: \"{0,number,integer}\") was converted (used charset: \"{1}\") to hex string (length: \"{2,number,integer}\"): \"{3}\""),
	HEX_STRING_FROM_BYTES_INPUT_BYTES_ARE_EMPTY_OR_NULL ("Impossible convert byte array to string because input byte array is empty (length 0) or NULL"),
	
	CIPHER_INIT_ECB ("Cipher was initialized for ECB mode"),
	CIPHER_INIT_CBC ("Cipher was initialized for CBC mode. Input data (secretKey in encoded format) for IV: length of byte array: \"{0,number,integer}\", in hex string format: \"{1}\". Output IV in hex string format: \"{2}\""),
	CIPHER_INIT_UNKNOWN ("Cipher was initialized for unknown mode"),
	CIPHER_START_GETTING_MAX_KEY_LENGTH (">>>	Start getting max allowed key length for chosen algorithm for cipher"),
	CIPHER_END_GETTING_MAX_KEY_LENGTH ("<<<	End getting max allowed key length for chosen algorithm for cipher"),
	CIPHER_CURRENT_KEY_LENGTH ("For algorithm: \"{0}\", max allowed key length: \"{1,number,integer}\", recommended key length: \"{2,number,integer}\". Will be use key length: \"{3,number,integer}\""),
	CIPHER_MAX_KEY_LENGTH ("Max allowed key length: \"{0,number,integer}\". Transformation string for Cipher: \"{1}\". Crypto provider: \"{2}\""),
	CIPHER_KEY_LENGTH_START_CHOOSE (">>>	Start choose key length"),
	CIPHER_KEY_LENGTH_END_CHOOSE ("<<<	End choose key length"),
	TRANSFORMATION_STRING_FOR_CRYPTO_ALGORITHM_START_COMPOUND (">>>	Start compound transformation string from algorithm name, mode, and padding"),
	TRANSFORMATION_STRING_FOR_CRYPTO_ALGORITHM_END_COMPOUND ("<<<	End compound transformation string from algorithm name, mode, and padding"),
	TRANSFORMATION_STRING_FOR_CRYPTO_ALGORITHM_IS_NULL ("Transformation string is null. Current transformation string: \"{0}\""),
	TRANSFORMATION_STRING_FOR_CRYPTO_ALGORITHM_IS_INVALID ("Transformation string is not valid (valid transformation string should be in the form of \"algorithm\" or \"algorithm/mode/padding\"). Current transformation string: \"{0}\""),
	TRANSFORMATION_STRING_FOR_CRYPTO_ALGORITHM_PADDING_IS_INVALID ("Transformation string contains a padding scheme that is not available. Current transformation string: \"{0}\""),
	TRANSFORMATION_STRING_FOR_CRYPTO_ALGORITHM_COMPOUND ("Transformation string compound: \"{0}\""),

	MESSAGE_DIGEST_START_CALCULATING_HASH (">>>	Start calculating hash"),
	MESSAGE_DIGEST_END_CALCULATING_HASH ("<<<	End calculating hash"),
	MESSAGE_DIGEST_INPUT_BYTES_ARE_EMPTY_OR_NULL ("Impossible calculate hash because input bytes array is empty (length 0) or NULL"),
	MESSAGE_DIGEST_OUTPUT_BYTES_ARE_EMPTY_OR_NULL ("Impossible calculate hash: emergency error: input byte array is not empty (length: \"{0,number,integer}\"), but output byte array is empty (length 0) or NULL"),
	MESSAGE_DIGEST_HASH_IS_CALCULATED ("Hash was calculated. Input data byte array has length: \"{0,number,integer}\". Output hash byte array has length: \"{1,number,integer}\". Hash algorithm: \"{2}\""),
	MESSAGE_DIGEST_ALGORITHM_IS_INVALID ("Impossible create instance of MessageDigest and calculate hash because no provider supports a MessageDigestSpi implementation for the specified algorithm. Hash algorithm: \"{0}\""),
	
	HASH_CHECKSUM_FILE_MD5_START (">>>	Start to calculate MD5 for file, filepath: \"{0}\""),
	HASH_CHECKSUM_FILE_MD5_END ("<<<	End of calculating MD5 for file. Filepath: \"{0}\", hash checksum: \"{1}\""),
	HASH_CHECKSUM_FILE_SHA1_START (">>>	Start to calculate SHA1 for file, filepath: \"{0}\""),
	HASH_CHECKSUM_FILE_SHA1_END ("<<<	End of calculating SHA1 for file. Filepath: \"{0}\", hash checksum: \"{1}\""),
	HASH_CHECKSUM_FILE_SHA256_START (">>>	Start to calculate SHA256 for file, filepath: \"{0}\""),
	HASH_CHECKSUM_FILE_SHA256_END ("<<<	End of calculating SHA256 for file. Filepath: \"{0}\", hash checksum: \"{1}\""),
	HASH_CHECKSUM_FILE_SHA384_START (">>>	Start to calculate SHA384 for file, filepath: \"{0}\""),
	HASH_CHECKSUM_FILE_SHA384_END ("<<<	End of calculating SHA384 for file. Filepath: \"{0}\", hash checksum: \"{1}\""),
	HASH_CHECKSUM_FILE_SHA512_START (">>>	Start to calculate SHA512 for file, filepath: \"{0}\""),
	HASH_CHECKSUM_FILE_SHA512_END ("<<<	End of calculating SHA512 for file. Filepath: \"{0}\", hash checksum: \"{1}\""),
	HASH_CHECKSUM_FILE_ADLER32_START (">>>	Start to calculate Adler32 for file, filepath: \"{0}\""),
	HASH_CHECKSUM_FILE_ADLER32_END ("<<<	End of calculating Adler32 for file. Filepath: \"{0}\", hash checksum: \"{1}\""),
	HASH_CHECKSUM_FILE_GOST_START (">>>	Start to calculate GOST (R 34.11-94) for file, filepath: \"{0}\""),
	HASH_CHECKSUM_FILE_GOST_END ("<<<	End of calculating GOST (R 34.11-94) for file. Filepath: \"{0}\", hash checksum: \"{1}\""),
	HASH_CHECKSUM_FILE_TTH_START (">>>	Start to calculate TTH (Tiger Tree Hash) for file, filepath: \"{0}\""),
	HASH_CHECKSUM_FILE_TTH_END ("<<<	End of calculating TTH (Tiger Tree Hash) for file. Filepath: \"{0}\", hash checksum: \"{1}\""),
	HASH_CHECKSUM_FILE_TTH2_START (">>>	Start to calculate TTH2 (Tiger2 Tree Hash) for file, filepath: \"{0}\""),
	HASH_CHECKSUM_FILE_TTH2_END ("<<<	End of calculating TTH2 (Tiger2 Tree Hash) for file. Filepath: \"{0}\", hash checksum: \"{1}\""),
	HASH_CHECKSUM_FILE_ED2K_START (">>>	Start to calculate ED2K for file, filepath: \"{0}\""),
	HASH_CHECKSUM_FILE_ED2K_END ("<<<	End of calculating ED2K for file. Filepath: \"{0}\", hash checksum: \"{1}\""),
	HASH_CHECKSUM_FILE_UNSUPPORTED_ALGORITHM ("Try to calculate hash cheksum of file, using unsupported algorithm. Algorithm: \"{0}\""),
	HASH_CHECKSUM_FILE_IMPOSSIBLE ("Impossible to calculate hash cheksum of file"),
	HASH_CHECKSUM_FILE_NOT_EQUALS ("Received and expected checksums of file are not equals. Expected checksums: \"{0}\", received checksums: \"{1}\", expected file size: \"{2}\", received file size: \"{3}\". File path: \"{4}\""),
	
	ZIP_START_COMPRESS (">>>	Start to zip-compress data. Input file path: \"{0}\", output file path for archive: \"{1}\""),
	ZIP_END_COMPRESS ("<<<	End compress data"),
	ZIP_COMPRESS_SUCCESSFUL ("Data was compressed successful. Archive file path: \"{0}\""),
	ZIP_COMPRESS_IMPOSSIBLE ("Impossible compress data. Path to archive which is not created: \"{0}\""),
	ZIP_START_UNCOMPRESS (">>>	Start to uncompress zip data. Input archive file path: \"{0}\", output path to folder for uncompressed data: \"{1}\""),
	ZIP_UNCOMPRESS_ENTITY ("Current uncompressed entity file path: \"{0}\", type: \"{1}\""),
	ZIP_UNCOMPRESS_SUCCESSFUL ("Archive uncompressed successful. Archive file path: \"{0}\", folder for uncompressed data filepath: \"{1}\""),
	ZIP_UNCOMPRESS_IMPOSSIBLE ("Impossible to uncompress data archive"),
	ZIP_END_UNCOMPRESS ("<<<	End of uncompress data. Successful uncompression (true) or not (false): \"{0}\""),
	
	REPORT_XML_BEGIN ("Begin to write xml file"),
	REPORT_XML_END ("End to write xml file"),
	REPORT_XML_SUCCESSFUL("Report xml file is created successful. File path: \"{0}\""),
	REPORT_XML_IMPOSSIBLE_GET_TRANSFORMERHANDLER ("Impossible get TransformerHandler, used for xml-report"),
	REPORT_XML_UNKNOWN_ERROR ("Unknown error when try to write into xml-report"),
	REPORT_XML_NOT_SET_OUT_FILE ("Was received null instead of output xml file"),
	PARSER_XML_UNKNOWN_ERROR ("Unknown error when try to parse xml file, Path to xnl file: \"{0}\""),

	
	STEGANOGRAPHY_IMAGE_LSB_START_PUT_FILE_INTO_IMAGES (">>>	Start of putting data file into images, data file path: \"{0}\", input image file path: \"{1}\", directory for processed files (images with putted data): \"{2}\""),
	STEGANOGRAPHY_IMAGE_LSB_PUT_FILE_DATA_CHUNK_INTO_IMAGES_SUCCESSFUL ("Successful putting chunk of data file into image. Original input image file path: \"{0}\", length of original image file (bytes): \"{1}\"; resized original image file path: \"{2}\", length of resized image file (bytes): \"{3}\"; input data file path: \"{4}\", length of input data file (bytes): \"{5}\"; size of buffer (max available number data bytes for putting in chosen resized image): \"{6}\"; number bytes, putted in chosen resized image: \"{7}\"; output image file path (image with putted data): \"{8}\", length of image with putted data (bytes): \"{9}\""),
	STEGANOGRAPHY_IMAGE_LSB_PUT_FILE_DATA_CHUNK_INTO_IMAGES_IMPOSSIBLE ("Imposible put chunk of data file into image. Original input image file path: \"{0}\", length of original image file (bytes): \"{1}\"; resized original image file path: \"{2}\", length of resized image file (bytes): \"{3}\"; input data file path: \"{4}\", length of input data file (bytes): \"{5}\"; size of buffer (max available number data bytes for putting in chosen resized image): \"{6}\"; number bytes we tryed to put in chosen resized image: \"{7}\""),
	STEGANOGRAPHY_IMAGE_LSB_END_PUT_FILE_INTO_IMAGES ("<<<	End of putting data file into images, number created images with data: \"{0}\""),
	STEGANOGRAPHY_IMAGE_LSB_IMAGE_DOES_NOT_EXISTS ("Image (with hidden data) does not exists, file path: \"{0}\""),
	STEGANOGRAPHY_IMAGE_LSB_START_EXTRACT_FILE_FROM_IMAGES (">>>	Start to extract data file from images, number images: \"{0}\", output data file path: \"{1}\""),
	STEGANOGRAPHY_IMAGE_LSB_EXTRACT_FILE_FROM_IMAGES_TOTAL_BYTES_EXPECT ("We need to extract next number bytes: \"{0}\" from next number images: \"{1}\" "),
	STEGANOGRAPHY_IMAGE_LSB_END_EXTRACT_FILE_FROM_IMAGES ("<<<	End of extracting data file from images, number extracted bytes: \"{0}\", extracted data file path:\"{1}\", length of extracted data file: \"{2}\", is that extracting successful: \"{3}\""),
	STEGANOGRAPHY_IMAGE_LSB_START_PUT_DATA_CHUNK_INTO_IMAGES ("Putting data chunk into images, input image file: \"{0}\", output image file: \"{1}\", length of data byte array: \"{2}\", length of data binary string: \"{3}\", first chars of data binary string: \"{4}\""),
	STEGANOGRAPHY_IMAGE_LSB_PUT_FILE_INTO_IMAGES_UNKNOWN_ERROR ("Impossible put data file with filepath: \"{0}\" into images, image file which will be used as data container: \"{1}\", and store processed images with hidden data into directory: \"{2}\""),
	STEGANOGRAPHY_IMAGE_LSB_EXTRACT_FILE_FROM_IMAGES_UNKNOWN_ERROR ("Imposiible extract data from images into output data file: \"{0}\""),
	
	MAIN_PROCESSOR_OPERATION_ENCRYPT_COMPRESS_HIDE_FILES_BEGIN ("Begin of block: encrypt data, compress, next - hide in images by LSB. Input data: \"{0}\", original image: \"{1}\", output directory for images: \"{2}\", output report file: \"{3}\""),
	MAIN_PROCESSOR_OPERATION_ENCRYPT_COMPRESS_HIDE_FILES_UNKNOWN_ERROR ("Unknown error in block: encrypt data, compress, next - hide in images by LSB. Input data: \"{0}\", original image: \"{1}\", output directory for images: \"{2}\", output report file: \"{3}\""),
	MAIN_PROCESSOR_OPERATION_ENCRYPT_COMPRESS_HIDE_FILES_END ("End of block: encrypt data, compress, next - hide in images by LSB. Result of operation: \"{0}\""),
	MAIN_PROCESSOR_OPERATION_DECRYPT_UNCOMPRESS_EXTRACT_FILES_BEGIN("Begin of block: decrypt data, uncompress, next - extract data from images (LSB). Input directory with images which contains data: \"{0}\", input xml file: \"{1}\", output directory for received data: \"{2}\""),
	MAIN_PROCESSOR_OPERATION_DECRYPT_UNCOMPRESS_EXTRACT_FILES_ERROR_NO_DATA_FOR_PROCESSING ("No data for processing block: decrypt data, uncompress, next - extract data from images (LSB). Probably image files which contains data, or report xml file, are corrupted"),
	MAIN_PROCESSOR_OPERATION_DECRYPT_UNCOMPRESS_EXTRACT_FILES_UNKNOWN_ERROR ("Unknown error in block: decrypt data, uncompress, next - extract data from images (LSB). Input directory with images which contains data: \"{0}\", input xml file: \"{1}\", output directory for received data: \"{2}\""),
	MAIN_PROCESSOR_OPERATION_DECRYPT_UNCOMPRESS_EXTRACT_FILES_END ("End of block: decrypt data, uncompress, next - extract data from images (LSB). Result of oeration: \"{0}\"")
	;
	
	
	private String description;
	private TextMessage(String msgDescription) {
		this.description = msgDescription;
	}
	public String getDescription() {
		return this.description;
	}
	

}